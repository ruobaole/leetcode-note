#DP
---

##1. Longest Ascending Subarray
Input: [10,9,2,5,3,7,101,18]
Output: 3
[3, 7, 101]

```java
// Using DP
// - The result longest ascending subarray can be ended at every element within the input array -->
// Thus, permulate all candidate subarray by iterating all elements;
// - M[i] is the length of the longest subarray ended at array[i];
// - M[i] = 1 for all i;
// - M[i] = array[i] > array[i-1] ? M[i-1] + 1 : 1;
// - return max of all M[i];
// Cause we only need M[i-1] to get M[i], we do not need array M but only prevLen;
//
// Time: O(N)

class Solution {
    public int longestAscendingSubarray(int[] input) {
        if (input == null || input.length == 0) {
            return 0;
        }
        int res = 1, MPrev = 1;
        for (int i = 1; i < input.length; i++) {
            if (input[i] > input[i-1]) {
                MPrev++;
            }
            else {
                MPrev = 1;
            }
            res = Math.max(res, MPrev);
        }
        return res;
    }
}

```

---
#2. Longest Increasing Subsequence (l. 300)
Given an unsorted array of integers, find the length of longest increasing subsequence.

##Example:
Input: [10,9,2,5,3,7,101,18]
Output: 4 

Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
Note:

There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
##Follow up:
Could you improve it to O(n log n) time complexity?

```java
// M[i] - longest subsequence ended at nums[i];
// M[i] is inited to 1 for all i;
// M[i]: for j from i-1 down to 0 find the max M[j] where nums[j] < nums[i]
//       M[i] = maxMj + 1;
// Return the max among M[];
//
// Time: O(N^2)
//
// To decrease time complexity: using M to keep track of the longest subsequence (so that is sorted
// and we can make use of binarySearch)
// M from 0 to nums.length is:
// [10], [9], [2], [2, 5], [2, 3], [2, 3, 7], [2, 3, 7, 101], [2, 3, 7, 18]
// To keep the smallest numbers among M[];
// - if (nums[i] > M[l]): just append nums[i] to M
// - else: find the correct position for nums[i] in M using binarySeach and replace it with nums[i] if 
// the original one is larger than nums[i];

class Solution {
    // public int lengthOfLIS(int[] nums) {
    //     if (nums == null || nums.length == 0) {
    //         return 0;
    //     }
    //     int[] M = new int[nums.length];
    //     M[0] = 1;
    //     int res = 1;
    //     for (int i = 1; i < nums.length; i++) {
    //         M[i] = 1;
    //         for (int j = i-1; j >= 0; j--) {
    //             if (nums[j] < nums[i]) {
    //                 M[i] = Math.max(M[i], M[j]+1);
    //             }
    //         }
    //         res = Math.max(res, M[i]);
    //     }
    //     return res;
    // }
    
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int[] M = new int[nums.length];
        M[0] = nums[0];
        int l = 0;
        for (int i = 1; i < nums.length; i++) {
            int pos = binarySearch(M, l, nums[i]);
            if (pos > l) {
                l = pos;
                M[pos] = nums[i];
            }
            if (nums[i] < M[pos]) {
                M[pos] = nums[i];
            }
        }
        return l+1;
    }
    
    protected int binarySearch(int[] array, int len, int target) {
        int left = 0, right = len;
        while (left+1 < right) {
            int mid = left + (right - left)/2;
            if (array[mid] == target) {
                return mid;
            }
            if (array[mid] < target) {
                left = mid;
            }
            else {
                right = mid;
            }
        }
        if (array[right] < target) {
            return len+1;
        }
        if (array[left] >= target) {
            return left;
        }
        return right;
    }
}

```