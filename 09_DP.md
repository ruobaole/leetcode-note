#DP
---

##1. Longest Ascending Subarray
Input: [10,9,2,5,3,7,101,18]
Output: 3
[3, 7, 101]

```java
// Using DP
// - The result longest ascending subarray can be ended at every element within the input array -->
// Thus, permulate all candidate subarray by iterating all elements;
// - M[i] is the length of the longest subarray ended at array[i];
// - M[i] = 1 for all i;
// - M[i] = array[i] > array[i-1] ? M[i-1] + 1 : 1;
// - return max of all M[i];
// Cause we only need M[i-1] to get M[i], we do not need array M but only prevLen;
//
// Time: O(N)

class Solution {
    public int longestAscendingSubarray(int[] input) {
        if (input == null || input.length == 0) {
            return 0;
        }
        int res = 1, MPrev = 1;
        for (int i = 1; i < input.length; i++) {
            if (input[i] > input[i-1]) {
                MPrev++;
            }
            else {
                MPrev = 1;
            }
            res = Math.max(res, MPrev);
        }
        return res;
    }
}

```

---
#2. Longest Increasing Subsequence (l. 300)
Given an unsorted array of integers, find the length of longest increasing subsequence.

##Example:
Input: [10,9,2,5,3,7,101,18]
Output: 4 

Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
Note:

There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
##Follow up:
Could you improve it to O(n log n) time complexity?

```java
// M[i] - longest subsequence ended at nums[i];
// M[i] is inited to 1 for all i;
// M[i]: for j from i-1 down to 0 find the max M[j] where nums[j] < nums[i]
//       M[i] = maxMj + 1;
// Return the max among M[];
//
// Time: O(N^2)
//
// To decrease time complexity: using M to keep track of the longest subsequence (so that is sorted
// and we can make use of binarySearch)
// M from 0 to nums.length is:
// [10], [9], [2], [2, 5], [2, 3], [2, 3, 7], [2, 3, 7, 101], [2, 3, 7, 18]
// To keep the smallest numbers among M[];
// - if (nums[i] > M[l]): just append nums[i] to M
// - else: find the correct position for nums[i] in M using binarySeach and replace it with nums[i] if 
// the original one is larger than nums[i];

class Solution {
    // public int lengthOfLIS(int[] nums) {
    //     if (nums == null || nums.length == 0) {
    //         return 0;
    //     }
    //     int[] M = new int[nums.length];
    //     M[0] = 1;
    //     int res = 1;
    //     for (int i = 1; i < nums.length; i++) {
    //         M[i] = 1;
    //         for (int j = i-1; j >= 0; j--) {
    //             if (nums[j] < nums[i]) {
    //                 M[i] = Math.max(M[i], M[j]+1);
    //             }
    //         }
    //         res = Math.max(res, M[i]);
    //     }
    //     return res;
    // }
    
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int[] M = new int[nums.length];
        M[0] = nums[0];
        int l = 0;
        for (int i = 1; i < nums.length; i++) {
            int pos = binarySearch(M, l, nums[i]);
            if (pos > l) {
                l = pos;
                M[pos] = nums[i];
            }
            if (nums[i] < M[pos]) {
                M[pos] = nums[i];
            }
        }
        return l+1;
    }
    
    protected int binarySearch(int[] array, int len, int target) {
        int left = 0, right = len;
        while (left+1 < right) {
            int mid = left + (right - left)/2;
            if (array[mid] == target) {
                return mid;
            }
            if (array[mid] < target) {
                left = mid;
            }
            else {
                right = mid;
            }
        }
        if (array[right] < target) {
            return len+1;
        }
        if (array[left] >= target) {
            return left;
        }
        return right;
    }
}

```
---

##3. Max Product Subarray
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

##Example 1:
Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

##Example 2:
Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.

```java
// Mlarge[i] -- the product of the largest contiguous subarray ending at nums[i]
// Msmall[i] -- the product of the smallest contiguous subarray ending at nums[i]
// Mlarge[i], Msmall[i] -- inited to nums[i] for all i;
// Mlarge[i] = Math.max(nums[i], nums[i] * Msmall[i-1], nums[i] * Mlarge[i-1])
// Msmall[i] = Math.min(nums[i], nums[i] * Msmall[i-1], nums[i] * Mlarge[i-1])
// return maximum among Mlarge[];
// Actually only need MlargePrev and MsmallPrev
//
// Time: O(N)

class Solution {
    public int maxProduct(int[] nums) {
        if (nums == null || nums.length == 0) {
            return Integer.MIN_VALUE;
        }
        int prevLarge = nums[0], prevSmall = nums[0], res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            int curLarge = Math.max(nums[i], Math.max(nums[i] * prevLarge, nums[i] * prevSmall));
            prevSmall = Math.min(nums[i], Math.min(nums[i] * prevLarge, nums[i] * prevSmall));
            prevLarge = curLarge;
            res = Math.max(res, prevLarge);
        }
        return res;
    }
}

```

---
##4. Max Product of Cutting Rope

Imagine you have a rope of integer length i, and you can make cut at every integer number length (e.g. 1, 2, 
3, ... i-1). Make any cuts you want to make the production of lengths of the final cutted ropes is the largest.
You have to make at least one cut!!!

###Example
Input: ---- 4
Output: 4 ([2, 2] -> cut once length 2 -- --)

Input: ----- 5
Ouput: 6 ([2, 3] --> cut once at length 2)

```java
// Assuming i > 1 (cause you have to make at least one cut and only legal at integer of length)
// M[i] - the largest product of cutting rope with length i;
// M[i] - inited to i-1 for all i (except M[1] = 1)
// M[i] - premulate all possible cut strategies by the position of the last cut --
//     M[i] = max(M[i-j], i-j) * j for all j from [1, i/2] (cut the i-j part or do not cut the i-j part
// which is larger?)
// return M[i]
//
// Time: O(N^2)

class Solution {
    public int cuttingRope(int len) {
        if (len <= 1) {
            return 0;
        }
        int[] M = new int[len+1];
        M[0] = 1;
        M[1] = 1;
        for (int i = 2; i <= len; i++) {
            M[i] = i-1;
            for (int j = 1; j <= i/2; j++) {
                M[i] = Math.max(M[i], Math.max(M[i-j], i-j) * j);
            }
        }
        return M[len];
    }
}

```